{% extends "main/base.html" %}
{% load static %}

<!--Titulo de la pagina-->
{% block title %}
    Funciones en Python
{% endblock %}

<div class="principal">
    <div class="row">
        <div class="col s3">
            <div class="row">
                <div class="col s12">
                    <br/><br/><br><br>
                  <h5><center>Contenido</center></h5>
                  <div class="card-panel yellow lighten-2">
                    <ul class="browser-default">
                        <li><a href="#Quef" class="grey-text text-darken-4">Qu√© son las funciones en Python </a></li>
                        <li><a href="#Defun" class="grey-text text-darken-4">C√≥mo definir una funci√≥n en Python </a></li>
                        <li><a href="#Comll" class="grey-text text-darken-4">C√≥mo usar o llamar a una funci√≥n </a></li>
                        <li><a href="#Senturn" class="grey-text text-darken-4">Sentencia return </a></li>
                        <li><a href="#Param" class="grey-text text-darken-4">Par√°metros de las funciones en Python </a></li>
                        <li><a href="#Ambito" class="grey-text text-darken-4">√Åmbito y ciclo de vida de las variables </a></li>
                    
                    </ul>
                  </div>
                </div>
              </div>
        </div>
        <div class="col s9">
            <h2><center>Funciones en Python</center></h2>
            <p>Las funciones en Python, y en cualquier lenguaje de programaci√≥n, son estructuras esenciales de c√≥digo. Una funci√≥n es un grupo de instrucciones que constituyen una unidad l√≥gica del programa y resuelven un problema muy concreto.</p>
            <p>Este tutorial es una gu√≠a que te muestra qu√© es una funci√≥n, cu√°l es su estructura y c√≥mo usarlas en tus aplicaciones.</p>

            <h4 id="Quef">Qu√© son las funciones en Python</h4>
            <p>Como te dec√≠a en la introducci√≥n, las funciones en Python constituyen unidades l√≥gicas de un programa y tienen un doble objetivo:</p>     
            <ul class="browser-default">
                <li><class="grey-text text-darken-4">Dividir y organizar el c√≥digo en partes mas sencillas</li>
                <li><class="grey-text text-darken-4">Encapsular el c√≥digo que se repite a lo largo de un programa para ser reutilizado.</li>
            </ul>
            <p>Python ya define de serie un conjunto de funciones que podemos utilizar directamente en nuestras aplicaciones. Algunas de ellas las has visto en tutoriales anteriores. Por ejemplo, la funci√≥n len(), que obtiene el n√∫mero de elementos de un objeto contenedor como una lista, una tupla, un diccionario o un conjunto. Tambi√©n hemos visto la funci√≥n print(), que muestra por consola un texto.</p>
            <p>Sin embargo, t√∫ como programador, puedes definir tus propias funciones para estructurar el c√≥digo de manera que sea m√°s legible y para reutilizar aquellas partes que se repiten a lo largo de una aplicaci√≥n. Esto es una tarea fundamental a medida que va creciendo el n√∫mero de l√≠neas de un programa.</p>
            <p>La idea la puedes observar en la siguiente imagen:</p>

            <img src="https://j2logo.com/wp-content/uploads/ejemplo-funcion-python.png"></img>
            <p>En principio, un programa es una secuencia ordenada de instrucciones que se ejecutan una a continuaci√≥n de la otra. Sin embargo, cuando se utilizan funciones, puedes agrupar parte de esas instrucciones como una unidad m√°s peque√±a que ejecuta dichas instrucciones y suele devolver un resultado.</p>
            <p>En el siguiente apartado te muestro c√≥mo definir una funci√≥n en Python.</p>

            <h4 id="Defun">C√≥mo definir una funci√≥n en Python</h4>
            <p>La siguiente imagen muestra el esquema de una funci√≥n en Python:</p>
            <img src="https://j2logo.com/wp-content/uploads/esquema-funciones-python.png"></img>
            <p>Para definir una funci√≥n en Python se utiliza la palabra reservada def. A continuaci√≥n viene el nombre o identificador de la funci√≥n que es el que se utiliza para invocarla. Despu√©s del nombre hay que incluir los par√©ntesis y una lista opcional de par√°metros. Por √∫ltimo, la cabecera o definici√≥n de la funci√≥n termina con dos puntos.</p>
            <p>Tras los dos puntos se incluye el cuerpo de la funci√≥n (con un sangrado mayor, generalmente cuatro espacios) que no es m√°s que el conjunto de instrucciones que se encapsulan en dicha funci√≥n y que le dan significado.</p>
            <p>En √∫ltimo lugar y de manera opcional, se a√±ade la instrucci√≥n con la palabra reservada return para devolver un resultado.</p>

            <p style="color:blue;"><b>! NOTA:</b> Cuando la primera instrucci√≥n de una funci√≥n es un string encerrado entre tres comillas simples ''' o dobles """, a dicha instrucci√≥n se le conoce como docstring. El docstring es una cadena que se utiliza para documentar la funci√≥n, es decir, indicar qu√© hace dicha funci√≥n.</p>

            <h4 id="Comll">C√≥mo usar o llamar a una funci√≥n</h4>
            <p>Para usar o invocar a una funci√≥n, simplemente hay que escribir su nombre como si de una instrucci√≥n m√°s se tratara. Eso s√≠, pasando los argumentos necesarios seg√∫n los par√°metros que defina la funci√≥n.</p>
            <p>Ve√°moslo con un ejemplo. Vamos a crear una funci√≥n que muestra por pantalla el resultado de multiplicar un n√∫mero por cinco:</p>

            <code>                
                <pre>
                    def multiplica_por_5(numero):
                    print(f'{numero} * 5 = {numero * 5}')

                    print('Comienzo del programa')    
                    multiplica_por_5(7)
                    print('Siguiente')
                    multiplica_por_5(113)
                    print('Fin')
                </pre>
            </code>

            <p>La funci√≥n multiplica_por_5() define un par√°metro llamado numero que es el que se utiliza para multiplicar por 5. El resultado del programa anterior ser√≠a el siguiente:</p>
            <code>                
                <pre>
                    Comienzo del programa
                    7 * 5 = 35
                    Siguiente
                    113 * 5 = 565
                    Fin
                </pre>
            </code>

            <p>Como puedes observar, el programa comienza su ejecuci√≥n en la <i>l√≠nea 4</i> y va ejecutando las instrucciones una a una de manera ordenada. Cuando se encuentra el nombre de la funci√≥n multiplica_por_5(), el flujo de ejecuci√≥n pasa a la primera instrucci√≥n de la funci√≥n. Cuando se llega a la √∫ltima instrucci√≥n de la funci√≥n, el flujo del programa sigue por la instrucci√≥n que hay a continuaci√≥n de la llamada de la funci√≥n.</p>

            <p style="color:blue;"><b>! IMPORTANTE:</b> Diferencia entre <b>par√°metro</b> y <b>argumento</b>. La funci√≥n multiplica_por_5() define un <i>par√°metro</i> llamado numero. Sin embargo, cuando desde el c√≥digo se invoca a la funci√≥n, por ejemplo, multiplica_por_5(7), se dice que se llama a multiplica por cinco con el <i>argumento</i> 7.</p>
            
            <h4 id="Senturn">Sentencia return</h4>
            <p>Anteriormente te indicaba que cuando acaba la √∫ltima instrucci√≥n de una funci√≥n, el flujo del programa contin√∫a por la instrucci√≥n que sigue a la llamada de dicha funci√≥n. Hay una excepci√≥n: usar la sentencia return. return hace que termine la ejecuci√≥n de la funci√≥n cuando aparece y el programa contin√∫a por su flujo normal.</p>
            <p>Adem√°s, return se puede utilizar para devolver un valor.</p>
            <p>La sentencia return es opcional, puede devolver, o no, un valor y es posible que aparezca m√°s de una vez dentro de una misma funci√≥n.</p>
            <p>A continuaci√≥n te muestro varios ejemplos:</p>

            <strong>return que no devuelve ning√∫n valor</strong>
            <p>La siguiente funci√≥n muestra por pantalla el cuadrado de un n√∫mero solo si este es par:</p>
            <code>
                <pre>
                    >>> def cuadrado_de_par(numero):
                    ...     if not numero % 2 == 0:
                    ...         return
                    ...     else:
                    ...         print(numero ** 2)
                    ...     
                    >>> cuadrado_de_par(8)
                    64
                    >>> cuadrado_de_par(3)
                </pre>
            </code>

            <strong>Varios return en una misma funci√≥n</strong>
            <p>La funci√≥n es_par() devuelve True si un n√∫mero es par y False en caso contrario:</p>
            <code>
                <pre>
                    >>> def es_par(numero):
                    ...     if numero % 2 == 0:
                    ...         return True
                    ...     else:
                    ...         return False
                    ...     
                    >>> es_par(2)
                    True
                    >>> es_par(5)
                    False
                </pre>
            </code>

            

            <strong>Devolver m√°s de un valor con return en Python</strong>
            <p>En Python, es posible devolver m√°s de un valor con una sola sentencia return. Por defecto, con return se puede devolver una tupla de valores. Un ejemplo ser√≠a la siguiente funci√≥n cuadrado_y_cubo() que devuelve el cuadrado y el cubo de un n√∫mero:</p>
            <code>
                <pre>
                    >>> def cuadrado_y_cubo(numero):
                    ...     return numero ** 2, numero ** 3
                    ... 
                    >>> cuad, cubo = cuadrado_y_cubo(4)
                    >>> cuad
                    16
                    >>> cubo
                    64
                </pre>
            </code>

            <p>Sin embargo, se puede usar otra t√©cnica devolviendo los diferentes resultados/valores en una lista. Por ejemplo, la funci√≥n tabla_del() que se muestra a continuaci√≥n hace esto:</p>
            <code>
                <pre>
                    >>> def tabla_del(numero):
                    ...     resultados = []
                    ...     for i in range(11):
                    ...         resultados.append(numero * i)
                    ...     return resultados
                    ... 
                    >>> res = tabla_del(3)
                    >>> res
                    [0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30]
                </pre>
            </code>

            <strong>En Python una funci√≥n siempre devuelve un valor</strong>
            <p>Python, a diferencia de otros lenguajes de programaci√≥n, no tiene procedimientos. Un procedimiento ser√≠a como una funci√≥n pero que no devuelve ning√∫n valor.</p>
            <p>¬øPor qu√© no tiene procedimientos si hemos vistos ejemplos de funciones que no retornan ning√∫n valor? Porque Python, internamente, devuelve por defecto el valor None cuando en una funci√≥n no aparece la sentencia return o esta no devuelve nada.</p>

            <code>
                <pre>
                    >>> def saludo(nombre):
                    ...     print(f'Hola {nombre}')
                    ...     
                    >>> print(saludo('j2logo'))
                    Hola j2logo
                    None
                </pre>
            </code>

            <p>Como puedes ver en el ejemplo anterior, el print que envuelve a la funci√≥n saludo() muestra None.</p>

            <h4 id="Param">Par√°metros de las funciones en Python</h4>

            <p>Tal y como te he indicado, una funci√≥n puede definir, opcionalmente, una secuencia de par√°metros con los que invocarla. ¬øC√≥mo se asignan en Python los valores a los par√°metros? ¬øSe puede modificar el valor de una variable dentro de una funci√≥n?</p>
            <p>Antes de contestar a estas dos preguntas, tenemos que conocer los conceptos de programaci√≥n paso por valor y paso por referencia.</p>

            <ul class="browser-default">
                <li><class="grey-text text-darken-4"><b>Paso por valor:</b> Un lenguaje de programaci√≥n que utiliza paso por valor de los argumentos, lo que realmente hace es copiar el valor de las variables en los respectivos par√°metros. Cualquier modificaci√≥n del valor del par√°metro, no afecta a la variable externa correspondiente.</li>
                <li><class="grey-text text-darken-4"><b>Paso por referencia:</b> Un lenguaje de programaci√≥n que utiliza paso por referencia, lo que realmente hace es copiar en los par√°metros la direcci√≥n de memoria de las variables que se usan como argumento. Esto implica que realmente hagan referencia al mismo objeto/elemento y cualquier modificaci√≥n del valor en el par√°metro afectar√° a la variable externa correspondiente.</li>
            </ul>

            <p>Muchos lenguajes de programaci√≥n usan a la vez paso por valor y por referencia en funci√≥n del tipo de la variable. Por ejemplo, paso por valor para los tipos simples: entero, float, ‚Ä¶ y paso por referencia para los objetos.</p>
            <p>Sin embargo, en Python todo es un objeto. Ya vimos esto en el tutorial sobre variables. Entonces, ¬øc√≥mo se pasan los argumentos en Python, por valor o por referencia? Lo que ocurre en Python realmente es que se pasa por valor la referencia del objeto üò± ¬øQu√© implicaciones tiene esto? B√°sicamente que si el tipo que se pasa como argumento es inmutable, cualquier modificaci√≥n en el valor del par√°metro no afectar√° a la variable externa pero, si es mutable (como una lista o diccionario), s√≠ se ver√° afectado por las modificaciones. As√≠ que, ¬°¬°¬°cuidado!!! Para complementar esta explicaci√≥n, no te pierdas la siguiente secci√≥n.</p>

            <h4 id="Ambito">√Åmbito y ciclo de vida de las variables</h4>
            <p>En cualquier lenguaje de programaci√≥n de alto nivel, toda variable est√° definida dentro de un <b>√°mbito</b>. Esto es, los sitios en los que la variable tiene sentido y d√≥nde se puede utilizar.</p>
            <p>Los par√°metros y variables definidos dentro de una funci√≥n tienen un √°mbito <i>local</i>, local a la propia funci√≥n. Por tanto, estos par√°metros y variables no pueden ser utilizados fuera de la funci√≥n porque no ser√≠an reconocidos.</p>
            <p>El <i>ciclo de vida</i> de una variable determina el tiempo en que una variable permanece en memoria. Una variable dentro de una funci√≥n existe en memoria durante el tiempo en que est√° ejecut√°ndose dicha funci√≥n. Una vez que termina su ejecuci√≥n, sus variables y par√°metros desaparecen de memoria y, por tanto, no pueden ser referenciados.</p>

            <code>
                <pre>
                    >>> def saludo(nombre):
                    ...     x = 10
                    ...     print(f'Hola {nombre}')
                    ...     
                    >>> saludo('j2logo')
                    Hola j2logo
                    >>> print(x)
                    Traceback (most recent call last):
                    File "&lt;input&gt;", line 1, in &lt;module&gt;
                    NameError: name 'x' is not defined
                </pre>
            </code>
            <p>Como ves, en el ejemplo anterior, al tratar de mostrar por pantalla el valor de la variable x, el int√©rprete mostrar√° un error.</p>
            <p>El siguiente ejemplo es diferente:</p>

            <code>
                <pre>
                    >>> def muestra_x():
                    ...     x = 10
                    ...     print(f'x vale {x}')
                    ...     
                    >>> x = 20
                    >>> muestra_x()
                    x vale 10
                    >>> print(x)
                    20
                </pre>
            </code>

            <p>Lo que sucede en este ejemplo es que dentro de la funci√≥n muestra_x() se est√° creando una nueva variable x que, precisamente, tiene el mismo nombre que la variable definida fuera de la funci√≥n. Por tanto, x dentro de la funci√≥n tiene el valor 10, pero una vez que la funci√≥n termina, x hace referencia a la variable definida fuera, cuyo valor es 20.</p>
            <p>Las variables definidas fuera de una funci√≥n tienen un √°mbito conocido como global y son visibles dentro de las funciones, d√≥nde solo se puede <b>consultar</b> su valor.</p>

            <code>
                <pre>
                    >>> y = 20
                    >>> def muestra_x():
                    ...     x = 10
                    ...     print(f'x vale {x}')
                    ...     print(f'y vale {y}')
                    ...     
                    >>> muestra_x()
                    x vale 10
                    y vale 20
                </pre>
            </code>
            <p>Para modificar dentro de una funci√≥n una variable definida fuera de la misma, hay que usar la palabra reservada global para declarar la variable dentro de la funci√≥n</p>